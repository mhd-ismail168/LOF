
import fs from 'fs';
import path from 'path';
import sharp from 'sharp';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const ASSETS_DIR = path.join(__dirname, '../src/assets');
const OUTPUT_DIR = path.join(ASSETS_DIR, 'optimized');
const INDEX_FILE = path.join(ASSETS_DIR, 'images.js');

// Support multiple sizes for responsive images
const SIZES = [
    { name: 'sm', width: 640 },
    { name: 'md', width: 1024 },
    { name: 'lg', width: 1920 }
];

// Ensure output directory exists
if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

// Helper to sanitize filename (remove extension and special chars)
const sanitizeName = (name) => name.replace(/\.[^/.]+$/, "").replace(/[^a-zA-Z0-9_]/g, "_");

async function optimizeImages() {
    console.log('Starting image optimization...');

    const files = fs.readdirSync(ASSETS_DIR).filter(file => /\.(png|jpg|jpeg)$/i.test(file));
    const imageExports = {};

    for (const file of files) {
        const inputPath = path.join(ASSETS_DIR, file);
        const name = sanitizeName(file);
        const ext = path.extname(file).toLowerCase();

        console.log(`Processing: ${file}`);

        // Track generated files for this image
        const generated = {
            original: `../assets/${file}`, // Relative import path for original fallback
            avif: {},
            webp: {}
        };

        const image = sharp(inputPath);
        const metadata = await image.metadata();

        // Generate sizes in AVIF and WebP
        for (const size of SIZES) {
            // Skip upscaling
            if (metadata.width < size.width && size.name !== 'lg') continue; // Always generate 'lg' or fallback? 
            // Better logic: if image is smaller than target, just copy or use original dim? 
            // Let's just limit width: if original < size.width, use original width but still convert format.
            const width = Math.min(metadata.width, size.width);
            const suffix = `-${size.name}`;

            // AVIF
            const avifFilename = `${name}${suffix}.avif`;
            const avifPath = path.join(OUTPUT_DIR, avifFilename);
            if (!fs.existsSync(avifPath)) {
                await image.clone().resize(width).avif({ quality: 60, effort: 4 }).toFile(avifPath);
            }
            generated.avif[size.name] = `../assets/optimized/${avifFilename}`;

            // WebP
            const webpFilename = `${name}${suffix}.webp`;
            const webpPath = path.join(OUTPUT_DIR, webpFilename);
            if (!fs.existsSync(webpPath)) {
                await image.clone().resize(width).webp({ quality: 75, effort: 4 }).toFile(webpPath);
            }
            generated.webp[size.name] = `../assets/optimized/${webpFilename}`;
        }

        imageExports[name] = generated;
    }

    // Generate Index File Content
    let fileContent = `// Auto-generated by scripts/optimize-images.js\n\n`;

    // Generate Imports for Fallbacks? 
    // Actually, dynamic imports or static? Static imports are better for bundling.
    // Let's generate static imports for everything to be safe with Vite's tree shaking.

    const imports = [];
    const exports = [];

    Object.entries(imageExports).forEach(([name, data]) => {
        // Original fallback
        const originalVar = `${name}_original`;
        imports.push(`import ${originalVar} from '${data.original}';`);

        // AVIF variants
        const avifVars = [];
        Object.entries(data.avif).forEach(([size, path]) => {
            const varName = `${name}_avif_${size}`;
            imports.push(`import ${varName} from '${path}';`);
            avifVars.push(`\${${varName}} ${size === 'sm' ? '640w' : size === 'md' ? '1024w' : '1920w'}`);
        });

        // WebP variants
        const webpVars = [];
        Object.entries(data.webp).forEach(([size, path]) => {
            const varName = `${name}_webp_${size}`;
            imports.push(`import ${varName} from '${path}';`);
            webpVars.push(`\${${varName}} ${size === 'sm' ? '640w' : size === 'md' ? '1024w' : '1920w'}`);
        });

        const exportObj = `
export const ${name} = {
    src: ${originalVar},
    srcSet: {
        avif: \`${avifVars.join(', ')}\`,
        webp: \`${webpVars.join(', ')}\`
    },
    alt: "${name.replace(/_/g, ' ')}"
};`;
        exports.push(exportObj);
    });

    fileContent += imports.join('\n') + '\n\n' + exports.join('\n');

    fs.writeFileSync(INDEX_FILE, fileContent);
    console.log(`\nGenerated ${INDEX_FILE} with ${Object.keys(imageExports).length} images.`);
    console.log('Done!');
}

optimizeImages().catch(console.error);
